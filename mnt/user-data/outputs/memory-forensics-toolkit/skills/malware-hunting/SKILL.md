---
name: malware-hunting
description: "Detect malware artifacts in memory dumps including process injection, code hollowing, reflective DLL loading, fileless malware, and shellcode. Use when triage has identified suspicious processes or when investigating a known compromise."
---

# Malware Hunting in Memory — Skill

## Purpose

Systematically detect and analyze malware artifacts in memory using Volatility 3 plugins. Covers the most common in-memory attack techniques: process injection, hollowing, DLL side-loading, and fileless payloads.

## Detection Techniques

### 1. Injected Code Detection (malfind)

```bash
vol -f <image> windows.malfind --pid <PID>
# Dump all suspicious memory regions:
vol -f <image> -o ./dumps/ windows.malfind --dump
```

**How it works**: Scans VAD (Virtual Address Descriptor) tree for memory regions that are executable but have no backing file on disk. Regions with `PAGE_EXECUTE_READWRITE` protection that contain PE headers or shellcode are flagged.

**Interpreting results**:
- `MZ` header at region start → injected PE (DLL/EXE)
- Shellcode patterns (`FC E8`, `EB FE`, `90 90 90`) → raw shellcode
- False positives: .NET JIT, some AV products, legitimate packers

### 2. Process Hollowing

```bash
vol -f <image> windows.hollowprocesses
```

**How it works**: Compares the in-memory image of a process with what the PEB (Process Environment Block) says should be loaded. If the on-disk executable doesn't match what's actually running in memory, the process has been hollowed.

**Indicators**:
- Legitimate process name (`svchost.exe`) but completely different code in memory
- Image base address mismatch between PEB and actual mapped PE

### 3. Hidden & Unlinked DLLs

```bash
vol -f <image> windows.ldrmodules --pid <PID>
```

**Interpreting the three columns**:
| InLoad | InInit | InMem | Meaning |
|--------|--------|-------|---------|
| True   | True   | True  | Normal loaded DLL |
| False  | False  | True  | Manually mapped (reflective injection) |
| False  | False  | False | Unlinked from all lists (rootkit/hiding) |
| True   | False  | True  | Loaded but never initialized (possible) |

### 4. YARA Scanning

```bash
# Scan all processes with a YARA rule file
vol -f <image> yarascan.YaraScan --yara-file malware_rules.yar

# Scan specific process
vol -f <image> yarascan.YaraScan --yara-file rules.yar --pid <PID>

# Scan kernel memory
vol -f <image> yarascan.YaraScan --yara-file rules.yar --kernel
```

**Useful YARA patterns to scan for**:
- Known malware families (use community rules from YARA-Rules, Florian Roth's rules)
- Cobalt Strike beacon signatures
- Metasploit shellcode patterns
- Base64-encoded PowerShell
- Common C2 framework strings

### 5. Process Anomaly Analysis

```bash
# Compare pslist vs psscan to find hidden processes
vol -f <image> windows.pslist -r csv > /tmp/pslist.csv
vol -f <image> windows.psscan -r csv > /tmp/psscan.csv
# Processes in psscan but NOT in pslist are suspicious

# Check for process ghosting
vol -f <image> windows.processghosting

# Suspicious threads
vol -f <image> windows.suspicious_threads
vol -f <image> windows.threads --pid <PID>
```

### 6. Dumping Suspicious Artifacts

```bash
# Dump a specific process executable
vol -f <image> -o ./dumps/ windows.dumpfiles --pid <PID>

# Dump process memory (full address space)
vol -f <image> -o ./dumps/ windows.memmap --dump --pid <PID>

# Dump specific DLL
vol -f <image> -o ./dumps/ windows.dlllist --pid <PID> --dump
```

### 7. Service & Persistence Analysis

```bash
# Enumerate Windows services
vol -f <image> windows.svcscan
vol -f <image> windows.svclist
vol -f <image> windows.svcdiff   # Compare service list vs scan

# Check for orphan kernel threads
vol -f <image> windows.orphan_kernel_threads

# Direct/indirect system calls (evasion technique)
vol -f <image> windows.direct_system_calls
vol -f <image> windows.indirect_system_calls
```

## Analysis Workflow

```
1. Run malfind → identify injected regions
2. Cross-reference PIDs with pstree → check parent legitimacy
3. Run ldrmodules on flagged PIDs → find hidden DLLs
4. Run hollowprocesses → detect hollowed binaries
5. Dump suspicious files → analyze with static tools
6. Run YARA scan → match known signatures
7. Check netscan → correlate network IOCs with malicious PIDs
8. Document all findings with PIDs, offsets, and hashes
```

## IOC Extraction Checklist

After identifying malware, extract these IOCs:
- Process name and PID
- Injected memory region virtual address and size
- SHA256 of dumped files
- Network connections (IP:port)
- Registry persistence keys
- Mutex names (from handles)
- Command-line arguments
- Parent process chain
